<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataCiteValidator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GBIF DOI Service</a> &gt; <a href="index.source.html" class="el_package">org.gbif.doi.service.datacite</a> &gt; <span class="el_source">DataCiteValidator.java</span></div><h1>DataCiteValidator.java</h1><pre class="source lang-java linenums">package org.gbif.doi.service.datacite;

import org.gbif.api.model.common.DOI;
import org.gbif.doi.metadata.datacite.DataCiteMetadata;
import org.gbif.doi.service.InvalidMetadataException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.SAXException;

import javax.xml.XMLConstants;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.validation.Validator;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.io.StringWriter;
import java.nio.charset.StandardCharsets;

/**
 * For the validation of DataCite metadata files.
 */
public final class DataCiteValidator {
<span class="fc" id="L31">  private static final Logger LOG = LoggerFactory.getLogger(DataCiteValidator.class);</span>

  private static final String DATACITE_XSD_LOCATION = &quot;http://schema.datacite.org/meta/kernel-4/metadata.xsd&quot;;
  private static final String DATACITE_SCHEMA_LOCATION = &quot;http://datacite.org/schema/kernel-4 &quot; + DATACITE_XSD_LOCATION;
  private static final String SCHEMA_LANG = &quot;http://www.w3.org/2001/XMLSchema&quot;;

  private static final Schema DATACITE_SCHEMA;
  private static final JAXBContext CONTEXT;

  private DataCiteValidator() {
  }

  static {
    try {
<span class="fc" id="L45">      SchemaFactory factory = SchemaFactory.newInstance(SCHEMA_LANG);</span>
<span class="fc" id="L46">      DATACITE_SCHEMA = factory.newSchema(new StreamSource(DATACITE_XSD_LOCATION));</span>
<span class="fc" id="L47">      CONTEXT = JAXBContext.newInstance(DataCiteMetadata.class);</span>
<span class="nc" id="L48">    } catch (JAXBException | SAXException e) {</span>
<span class="nc" id="L49">      throw new IllegalStateException(&quot;Fail to setup JAXB&quot;, e);</span>
<span class="fc" id="L50">    }</span>
<span class="fc" id="L51">  }</span>

  /**
   * Produces a validated xml representation of the data cite metadata.
   * The DOI inside the metadata is overwritten to always represent the given DOI
   * and the generated XML is validated according to the datacite xsd schema.
   *
   * @return xml string
   * @throws InvalidMetadataException if the generated xml failed validation, e.g. missing mandatory elements
   */
  public static String toXml(DOI doi, DataCiteMetadata data) throws InvalidMetadataException {
    // make sure we use the right doi inside the metadata
<span class="fc" id="L63">    data.setIdentifier(DataCiteMetadata.Identifier.builder()</span>
<span class="fc" id="L64">        .withValue(doi.getDoiName())</span>
<span class="fc" id="L65">        .withIdentifierType(&quot;DOI&quot;)</span>
<span class="fc" id="L66">        .build()</span>
    );
<span class="fc" id="L68">    LOG.debug(&quot;Metadata XML is being validated {}&quot;, doi);</span>
<span class="fc" id="L69">    return toXml(data, true);</span>
  }

  /**
   * Produces a validated xml representation of the data cite metadata.
   * The boolean flag 'validate' it is used to specify if it should be validated.
   * The generated XML is validated according to the datacite xsd schema.
   *
   * @return xml string
   * @throws InvalidMetadataException if the generated xml failed validation, e.g. missing mandatory elements
   */
  public static String toXml(DataCiteMetadata data, boolean validate) throws InvalidMetadataException {
    // (un)marshaller are not thread safe and need to be created on each authCall
<span class="fc" id="L82">    try (StringWriter writer = new StringWriter()) {</span>
<span class="fc" id="L83">      Marshaller m = CONTEXT.createMarshaller();</span>
<span class="fc" id="L84">      m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);</span>
<span class="fc" id="L85">      m.setProperty(Marshaller.JAXB_SCHEMA_LOCATION, DATACITE_SCHEMA_LOCATION);</span>

<span class="fc" id="L87">      m.marshal(data, writer);</span>
<span class="fc" id="L88">      writer.flush();</span>

<span class="fc" id="L90">      String xml = writer.toString();</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">      if (validate) {</span>
        // validate the xml before we return it
<span class="fc" id="L93">        validateMetadata(xml);</span>
      }
<span class="fc" id="L95">      return xml;</span>
<span class="nc" id="L96">    } catch (JAXBException e) {</span>
<span class="nc" id="L97">      throw new InvalidMetadataException(e);</span>
<span class="nc" id="L98">    } catch (IOException e) {</span>
<span class="nc" id="L99">      throw new IllegalStateException(e);</span>
    }
  }

  /**
   * Create metadata from String XML.
   *
   * @param xml string metadata
   * @return DataCiteMetadata
   * @throws JAXBException in case of unmarshalling problems
   */
  public static DataCiteMetadata fromXml(String xml) throws JAXBException {
<span class="fc" id="L111">    return fromXml(new ByteArrayInputStream(xml.getBytes(StandardCharsets.UTF_8)));</span>
  }

  /**
   * Create metadata from byte stream.
   *
   * @param in byte stream
   * @return DataCiteMetadata
   * @throws JAXBException in case of unmarshalling problems
   */
  public static DataCiteMetadata fromXml(InputStream in) throws JAXBException {
    // (un)marshaller are not thread safe and need to be created on each call
<span class="fc" id="L123">    Unmarshaller m = CONTEXT.createUnmarshaller();</span>
<span class="fc" id="L124">    return (DataCiteMetadata) m.unmarshal(in);</span>
  }

  /**
   * Validate metadata.
   *
   * @param xml DataCite xml metadata to validate (String)
   * @throws InvalidMetadataException in case of invalid metadata
   */
  public static void validateMetadata(String xml) throws InvalidMetadataException {
<span class="fc" id="L134">    validateMetadata(new StreamSource(new StringReader(xml)));</span>
<span class="fc" id="L135">  }</span>

  /**
   * Validate metadata.
   *
   * @param xml DataCite xml metadata to validate (byte stream)
   * @throws InvalidMetadataException in case of invalid metadata
   */
  public static void validateMetadata(InputStream xml) throws InvalidMetadataException {
<span class="nc" id="L144">    validateMetadata(new StreamSource(xml));</span>
<span class="nc" id="L145">  }</span>

  /**
   * Validate metadata.
   *
   * @param source DataCite xml metadata to validate (abstract source)
   * @throws InvalidMetadataException in case of invalid metadata
   */
  public static void validateMetadata(Source source) throws InvalidMetadataException {
    try {
<span class="fc" id="L155">      final Validator validator = getValidator();</span>
<span class="fc" id="L156">      validator.validate(source);</span>
<span class="fc" id="L157">      LOG.debug(&quot;Metadata XML passed validation&quot;);</span>
<span class="nc" id="L158">    } catch (SAXException e) {</span>
<span class="nc" id="L159">      throw new InvalidMetadataException(e);</span>
<span class="nc" id="L160">    } catch (IOException e) {</span>
      // cant happen, we had a string in memory already!
<span class="nc" id="L162">      throw new IllegalStateException(e);</span>
<span class="fc" id="L163">    }</span>
<span class="fc" id="L164">  }</span>

  /**
   * A new instance of validator on each call.
   * Validator instances are NOT thread-safe.
   *
   * @return validator
   */
  private static synchronized Validator getValidator() throws SAXException {
<span class="fc" id="L173">    final Validator validator = DATACITE_SCHEMA.newValidator();</span>
<span class="fc" id="L174">    validator.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);</span>
<span class="fc" id="L175">    validator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, &quot;&quot;);</span>
<span class="fc" id="L176">    return validator;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>